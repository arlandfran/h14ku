# Testing

To ensure that the development environment is consistent across different machines, the .vscode directory was commited to the repository to ensure that:

1. [Black](https://black.readthedocs.io/en/stable/) is the provided python formatter
2. [Pylint](https://pylint.org/) is the default linter
3. [Pytest](https://docs.pytest.org/en/6.2.x/) is enabled for the test runner

This assumes that you are using Visual Studio Code as your code editor.

## Packages / extensions

- [pytest-flask](https://pytest-flask.readthedocs.io/en/latest/) - Plugin for pytest that provides helpful fixtures and helpers for Flask

- [pytest-cov](https://pytest-cov.readthedocs.io/en/latest/) / [coverage.py](https://coverage.readthedocs.io/en/6.1.2/index.html) - Provide code coverage for pytest

- [faker](https://faker.readthedocs.io/en/master/) - Python package that generates fake data

## Setup

Python tests are located in the `/tests` directory and are split into functional tests and unit tests.

The pytest fixtures used for testing are loaded as plugins inside the `conftest.py` file.

The test configuration for Flask enables testing, disables CSRF validation for requests and provides a MONGO_URI that connects to a test database. A CSRF test config is also setup with CSRF validation enabled to test CSRF protection.

## Running the tests

`npm run test` in the terminal to run pytest and generate a code coverage report.

You can also run the tests in VS Code using the built-in test runner. The advantage of this is you can run tests individually, from the side bar or your code, and also debug tests.

## Writing tests

Each test was written following the GIVEN, WHEN, THEN methodology from the BDD (Behaviour Driven Development) paradigm.

```python
"""
GIVEN some sort of state or context
WHEN some action is carried out
THEN describe the results you expect following that action
"""
```

## Fixtures

Fixtures provide their values for test functions to use.

For example:

```python
@pytest.fixture(scope="module")
def mongo():
test_app = create_app(config_name="test")
test_mongo = PyMongo()
  with test_app.test_client():
    with test_app.app_context():
      test_mongo.init_app(test_app)
      yield test_mongo

def test_if_correct_db(mongo): # pass in mongo fixture to test function
    """
    GIVEN a Mongo client
    WHEN connecting to a database during testing
    THEN check the client is connected to the test database
    """
    assert mongo.db.name == "test"
```

This fixture yields a PyMongo client for testing. Setting `scope="module"` means the fixture is destroyed during teardown of the last test in the module.

Now you can pass this fixture as an argument to your test function and access the return value in the test.

> In this project, any fixture that writes data to MongoDB also cleans itself up on teardown so that the test database doesn't get bloated with any test data.

Fixtures can also request other fixtures. This allows you to compose a generic fixture and then reuse that for different test cases.

For example:

```python
@pytest.fixture(scope="module")
def user(mongo): # uses mongo fixture
    same_password = fake.password(length=8)
    user = {
        "email": fake.ascii_safe_email(),
        "username": fake.user_name(),
        "password": same_password,
        "password2": same_password,
    }
    yield user
    mongo.db.users.delete_one({"email": user["email"]})

@pytest.fixture()
def different_passwords(user): # uses user fixture
    user = {
        "email": user["email"],
        "username": user["username"],
        "password": "1234",
        "password2": "5678",
    }
    return user
```

Note that the user fixture _yields_ the user dict instead of returning it. The main reason for this is that any teardown code placed after `yield` is executed automatically by pytest. Say you were to use this fixture to test registration, you may want to remove the registered user from the test database at the end of testing. Since the scope of the fixture is `module`, the code after the yield statement is only executed after every other test in the module is run.

## Code Validation

**HTML**

Because this project was built as a single page application (SPA), the HTML could not be validated using the [W3C Markup Validator](https://validator.w3.org/) as it would only validate the single index.html served by Flask and not any of the other pages. Validating by file input would not help as Svelte, the JavaScript framework used for this project, allows for the use of variables and logic blocks directly in the markup and the validator would throw errors. For these reasons the HTML was not validated.

**CSS**

CSS styles were validated with the [W3C CSS Validator](https://jigsaw.w3.org/css-validator/). All the components passed validation with only three errors being thrown for regarding CSS transitions. These errors were left as the values used were generated by TailwindCSS and Svelte for transition animations and are hard to change. The rest are warnings regarding autoprefixers vendor extensions and CSS variables.

**JS**

Javascript was validated with [JSHint](https://jshint.com/). As Svelte was used, JSHint throws unused variable errors as it does not recognise the function is called in the markup and also undefined variable errors as Svelte has syntactic sugar such as the `$` reactive statement e.g. `$: count = onClick()`.

**Python**

Python code was linted along the way using [Pylint](https://pylint.org/) and enabling it in VS Code. [PEP8 online](http://pep8online.com/) was also used for validation but due to the way circular imports work in Flask, some errors were left unavoidable such as `module level import not at top of file`.

## User Story Testing

- As a user, I want to be able to learn how haikus are structured so that I can write my own haikus

  - Users can reference a syllable count beneath the text area to keep track of their haiku structure

- As a user, I want to be able to view other user's haikus so that I can see what other user's have written

  - User can see the first 20 posts of three different filters: popular, newest and my haikus

- As a user, I want to be able to post my haiku so that I can share it with other users on the website

  - Users are able to post haikus if they are logged in

- As a user, I want to be able to easily copy my post so that I can share my haikus on any platform outside of the website

  - Users can click on the copy button under the text area and the text will automatically be copied to their clipboard

- As a user, I want to be able to save my haikus so that I can read them at any later date

  - Users can go to their account page and see all their posted haikus

- As a user, I want to be able to edit my haiku after I've posted it so that I can fix any typos or make any amendments if I need to

  - Users can edit their haikus and commments after posting using the edit icon and then submitting their changes

## Responsive Testing

Website responsiveness was tested on [Google's Mobile Friendly Test](https://search.google.com/test/mobile-friendly) - Passed and [Responsinator](https://www.responsinator.com/) - Mobile and tablet devices test.

## Accessibility Testing

Accessibility was harder to test due to being an SPA. [WAVE](https://wave.webaim.org/) could not detect my pages but Microsoft's [Accessibility Insights for Web extension](https://accessibilityinsights.io/en/) was able to work and I was able to fix every issue.

## Defensive Design

- If user is logged in, then the login and register pages redirect to the home page.

- If the user navigates to a page that does not exists then a 404 page is shown.

- Tooltips will still show if the user tabs to disabled buttons like `post` to inform the user that they need to log in before they can take actions on the site

## Edge Cases

- Very rarely if a user likes a comment, sometimes the state is not tracked properly and a user is able to keep liking comments beyond the one like per user limit
